<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Free Monads and Free Applicatives</title>

    <meta name="description" content="TITLE">
    <meta name="author" content="AUTHOR">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">
    <link rel="stylesheet" href="css/deck.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

<!-- ########################################################################################### -->
<!-- START                                                                                       -->
<!-- ########################################################################################### -->

<section data-markdown data-background="images/codecentric-title-background-16x9.png"><script type="text/template">
## Free Monads and Free Applicatives

Markus Hauck, codecentric (@markus1189)
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### What this talk is about

- Write Dsl using Free Monad / Free Applicative
- Explore the specific pros and cons
- Show how to exploit Free Applicatives
- Example: Query GitHub API
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### Before We Start

- Requirements:
  - functional programming library of your choice
  - we will use cats, but could have used scalaz just as well
  - familiarity with GitHub (helpful?)
- Plan:
  - write a Dsl to query GitHub
  - using free monads
  - using free applicatives
  - using both
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### GitHub API - Issues
Given an owner and a repo, list issues
<img data-src="images/issues.png">
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### GitHub API - Comments
Given an issue, find all comments
<img data-src="images/comments.png">
Finally, retrieve the full name from a login
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### GitHub API - Full Names
Finally, retrieve the full name (if given) from a login
<img data-src="images/login.png">
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### A first draft

<pre><code class="scala" data-trim data-noescape>
def listIssues(owner: Owner,
               repo: Repo
              ): Future[List[Issue]] =

def getComments(owner: Owner,
                repo: Repo,
                issue: Issue
               ): Future[List[Comment]] = ???

def getUser(login: UserLogin
           ): Future[User] = ???
</code></pre>
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### The Start: Free Monads
- free monads offer simple way to construct your Dsl:
    1. write your *instructions* as an ADT
    2. use *Free* to lift them into the free monad
    3. write an interpreter
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### 1. Write your *instructions* as an ADT

<pre><code class="scala" data-trim data-noescape>
sealed trait GitHub[A]

case class ListIssues(owner: Owner, repo: Repo)
  extends GitHub[List[Issue]]

case class GetComments(owner: Owner, repo: Repo, issue: Issue)
  extends GitHub[List[Comment]]

case class GetUser(login: UserLogin)
  extends GitHub[Option[User]]
</code></pre>
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### 2. Use *Free* to lift instructions
<pre><code class="scala" data-trim data-noescape>
type GitHubMonadic[A] = Free[GitHub, A]

def listIssues(owner: Owner,
               repo: Repo
              ): GitHubMonadic[List[Issue]] =
  Free.liftF(ListIssues(owner,repo))

def getComments(owner: Owner,
                repo: Repo,
                issue: Issue
               ): GitHubMonadic[List[Comment]] =
  Free.liftF(GetComments(owner, repo, issue))

def getUser(login: UserLogin
           ): GitHubMonadic[User] =
  Free.liftF(GetUser(login))
</code></pre>
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### 3. write an interpreter
We could hand-roll our own recursive traversal, but `Free` already
defines `foldMap`:

<pre><code class="scala" data-trim data-noescape>
sealed abstract class Free[S[_], A] {
  final def foldMap[M[_]:Monad](f: S ~> M): M[A] = ???
}
</code></pre>

- define a natural transformation, from `GitHub` to target type
constructor
<pre><code class="scala" data-trim data-noescape>
type Target[A]
val interpret: GitHub ~> Target = ???
</code></pre>
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### 3. write an interpreter

<pre><code class="scala" data-trim data-noescape>

def step(client:Client) : GitHub ~> Future =
  new (GitHub ~> Future) {

    def apply[A](fa: GitHub[A]): Future[A] = fa match {

      case ffa @ GetComments(_, _, _) =>
        client.fetch(Endpoint(ffa)).map(parseComment)

      case ffa @ GetUser(_) =>
        client.fetch(Endpoint(ffa)).map(parseUser)

      case ffa @ ListIssues(_,_) =>
        client.fetch(Endpoint(ffa)).map(parseIssue)
    }
  }
</code></pre>

</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### (4.) Write programs!

<pre><code class="scala" data-trim data-noescape>
def allUsers(
  owner: Owner,
  repo: Repo
): GitHubMonadic[List[(Issue,List[(Comment,User)])]] = for {

  issues <- listIssues(owner,repo)

  issueComments <- issues.traverseU(issue =>
    getComments(owner,repo,issue).map((issue,_)))

  users <- issueComments.traverseU { case (issue,comments) =>
    comments.traverseU(comment =>
      getUser(comment.user).map((comment,_))).map((issue,_))
  }
} yield users
</code></pre>
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### Done?

- well the DSL came out okay, but what about:
  - parallelism?
  - efficiency? (API is rate limited!)
- let's see how our program executes
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### Done?

ASCIINEMA
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
<img data-src="images/all-users-monad.png">
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### Recap of Free Monads

- quite popular and many tutorials
- very expressive
- forced *sequential* execution :(
- *not* statically analyzable :(
  - `Free` is opaque,  have to execute & feed result
  - supplying dummy values might change whole program
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### Free Applicatives

- problem: monads are too powerful
- applicatives < monads
- let's try Free Applicatives then!
- remember the required steps?
  1. write your *instructions* as an ADT (✓)
  2. use *FreeApplicative* to lift them into the free applicative functor
  3. write an interpreter (✓)
- we can reuse the instructions and the natural transformation
</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### Free Applicatives - Smart Constructors

<pre><code class="scala" data-trim data-noescape>
type GitHubApplicative[A] = FreeApplicative[GitHub, A]

def listIssues(owner: Owner,
               repo: Repo
              ): GitHubApplicative[List[Issue]] =
  FreeApplicative.lift(ListIssues(owner,repo))

def getComments(owner: Owner,
                repo: Repo,
                issue: Issue
               ): GitHubApplicative[List[Comment]] =
  FreeApplicative.lift(GetComments(owner, repo, issue))

def getUser(login: UserLogin
           ): GitHubApplicative[User] =
  FreeApplicative.lift(GetUser(login))
</code></pre>

</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### Free Applicatives - Write Programs

<pre><code class="scala" data-trim data-noescape>
val logins = List(UserLogin("markus1189"), UserLogin("..."), ???)
val result: GitHubApplicative[List[User]] = logins.traverseU(getUser)
</code></pre>

</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
### Free Applicatives - Write Programs

<pre><code class="scala" data-trim data-noescape>
def getUsers(logins: List[UserLogin]
            ): GitHubApplicative[List[User]] =
  logins.traverseU(getUser)
</code></pre>

</script></section>

<!-- ########################################################################################### -->

<section data-markdown><script type="text/template">
## Thank you!

&nbsp;

[![License](https://i.creativecommons.org/l/by/4.0/88x31.png "License")](http://creativecommons.org/licenses/by/4.0)<br>

<span class="license">This work is licensed under a [Creative Commons Attribution 4.0 International License](http://creativecommons.org/licenses/by/4.0) and powered by [reveal.js](https://github.com/hakimel/reveal.js) under its [LICENSE](https://github.com/hakimel/reveal.js/blob/master/LICENSE).</span>
</script></section>

<!-- ########################################################################################### -->
<!-- END                                                                                         -->
<!-- ########################################################################################### -->

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
