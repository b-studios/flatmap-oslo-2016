\documentclass[compress]{beamer}
\usepackage{pgf}
\usepackage{color}
% \usepackage{minted}

% \renewcommand\texttt[1]{\mintinline{haskell}/#1/}

% \newminted{scala}{linenos}
% \newmintedfile{scala}{linenos,firstnumber=1}
% \newmint{scala}{}

\mode<presentation>

\input{beamer-setup}

% \usepackage{minted}
% \usemintedstyle{manni}

\title{Free Monads and Free Applicatives}

\author{Markus Hauck}

% \date{November 6, 2015}

\begin{document}

\begin{frame}
  \titlepage{}
\end{frame}

\section{Introduction}
\label{sec:Introduction}

\begin{frame}
  \frametitle{Writing DSLs}
  \begin{itemize}
  \item DSLs can be super handy
  \item popular way to write embedded DSL in Scala: Free Monads
  \item (less?) popular way: Free Applicatives
  \item this talk: use free monads and free applicatives
  \item discover the trade-offs
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Requirements}
  \begin{itemize}
  \item use functional programming library of your choice
  \item examples will use \texttt{cats}
  \item what you will see:
    \begin{itemize}
    \item DSL to speak with GitHub's API
    \item using free monads
    \item using free applicatives
    \item benefits of free applicatives
    \item using \textbf{both} and profit
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Goal of our DSL}
  \begin{itemize}
  \item offer interface to web API for GitHub
  \item let's keep it simple (or: I am lazy):
    \begin{enumerate}
    \item retrieve comment information from an issue
    \item get full name of a user from the login
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Design Space}
  \begin{itemize}
  \item when designing our DSL, we have the choice between a
    \textit{deep} or a \texttt{shallow} embedding
  \item \textit{deep} = explicit representation of abstract syntax as
    ADT, assign syntax via traversal
  \item \textit{shallow} = no explicit AST, give semantics directly
  \item Free Monads/Applicatives are ``very''* deep
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{A First Draft}
  \begin{itemize}
  \item in order to get an idea, this is how our DSL should look like:
  \end{itemize}
\end{frame}

\section{Free Monads}
\label{sec:free-monads}

\begin{frame}
  \frametitle{Starting with free monads}
  \begin{itemize}
  \item free monads offer easy way to write embedded DSLs
    \begin{enumerate}
    \item write your instructions as an ADT
    \item use \texttt{Free} to lift them into the free monad
    \item use monadic interface to write programs
    \item interpret the resulting programs (possibly in many ways)
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{1. Write your instructions}
  \begin{itemize}
  \item our instructions are:
    \begin{enumerate}
    \item retrieve comment information from an issue
    \item get full name of a user from the login
    \end{enumerate}
  \item so we start with:
    TODO
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{2. use Free for lifting}
  \begin{itemize}
  \item for a better interface to users, provide smart constructors
    for each instruction of our DSL
  \item TODO
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{3. Use monadic interface}
  \begin{itemize}
  \item aaaaand we can write our program:
    TODO
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{4. Interpretation}
  \begin{itemize}
  \item now that we have a program, we have to give it semantics
  \item define a NaturalTransformation (does not care about the
    elements, only the shape)
  \item a natural transformation translate exactly \textbf{one}
    instruction, recursion is handled by \texttt{foldMap}
  \item TODO
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{That's it}
  \begin{itemize}
  \item that's it, we are done, time to party
  \item wait a moment! maybe let's review what we have
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Review of our current design}
  \begin{itemize}
  \item the good
    \begin{itemize}
    \item easy to use DSL
    \item monadic expressiveness: looping, branching, etc.
    \end{itemize}
  \item the bad
    \begin{itemize}
    \item rate limiting of the API (without auth: 60/hour, with:
      5000/hour)
    \item every call counts! We want to avoid unnecessary calls.
    \item no way to statically analyze programs! (following slides)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Limits of Free Monads}
  \begin{itemize}
  \item given a program written in our DSL there is no way to ``look
    ahead''
  \item during interpretation we have to provide some sort of value
    for the continuation!
  \item arbitrary value might change everything
  \item conclusion: free monads are nice, but the power comes at a
    high cost
  \end{itemize}
\end{frame}

\section{Free Applicatives}
\label{sec:free-applicatives}

\begin{frame}
  \frametitle{Applicative Functors}
  \begin{itemize}
  \item given the limitation of free monads, coming from
    expressiveness
  \item maybe there is something less powerful?
  \item the answer is the Applicative Functor
  \item limitation: no dependency of ``previous'' effects
  \item or: structure of computation is static (no branching on
    effectful results for you)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Free Applicative Functors}
  \begin{itemize}
  \item like Free Monads, but for Applicative Functors
  \item very similar to Free Monads:
    \begin{itemize}
    \item write your instructions as an ADT (check)
    \item use (\texttt{Free}) \texttt{FreeApplicative} to lift
    \item use (monadic) applicative interface to write programs
    \item interpret the resulting programs (possibly in many ways)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Free Applicative Functors}
  \begin{itemize}
  \item we can reuse our natural transformation
  \item and interpret programs
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Limits of Applicative Functors}
  \begin{itemize}
  \item the ``shape'' of the computation is known in advance
  \item no interdependencies
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Advantages of Applicative Functors}
  \begin{itemize}
  \item given these limitation, why even bother?
  \item remember?
    \begin{itemize}
    \item no interdependencies $\rightarrow$ parallel
    \item static structure $\rightarrow$ static analysis
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Parallel Execution for Free}
  \begin{itemize}
  \item given a program written using applicative DSL
  \item no interdependencies means we can do parallel execution
  \item in our example, rely on pooling of http client and submit all
    at once
  \item TODO: picture or gif?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Static Analysis of Programs}
  \begin{itemize}
  \item real world: rate limited APIs
  \item in our example, we perform duplicate requests to get the full
    name of a user
  \item static analysis: look at program and extract the requests for
    user names
  \item eliminate duplicates and interpret the program only for unique
    logins
  \item transparent for users of our DSL, they can write as
    inefficient programs as they want
  \end{itemize}
\end{frame}

\section{Combination}

\begin{frame}
  \frametitle{The Combination}
  \begin{itemize}
  \item for ``real'' programs we still need monadic power
  \item but free applicatives \textbf{are} nice, damn
  \item if only we could combine the best of both worlds...
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Coproducts to the rescue}
  \begin{itemize}
  \item the key characteristic: Functors compose
  \item product,\textbf{coproduct}
  \item instead of having ADT with out instructions, how about having
    \textbf{either} a free applicative program \textbf{or} a normal
    instruction
  \item we embed applicative programs inside of our free monads
  \end{itemize}
\end{frame}

\end{document}